# `Java`基础

## 抽象类和接口的区别是什么?

| **异同点**   | **接口**                 | **抽象类**        |
| --------- | ---------------------- | -------------- |
| **与类的关系** | (多)实现                  | (单)继承          |
| **成员变量**  | 静态常量(类常量)              | [实例/静态][变量/常量] |
| **抽象方法**  | 有                      |                |
| **构造方法**  | 无                      | 有              |
| **实例化**   | 不能直接实例化, 必须被实现接口或继承抽象类 |                |
| **继承**    | 多继承                    | 单继承            |
| **设计目的**  | 约束类的行为                 | 代码复用,强调所属关系    |

## `==`和`equals`的区别是什么?

| **对比项**  | **==** | **equals**                   |
| -------- | ------ | ---------------------------- |
| **基本类型** | 比较值    | 不支持                          |
| **引用类型** | 比较内存地址 | 未重写时采用==比较<br><br>重写后比较对象的内容 |

## 字符串常量方式创建和`new`方式创建有什么区别?
**字符串常量方式创建:**

查找常量池中是否存在该字符串对象

a. 如果存在直接复用常量池中的字符串对象

b. 如果不存在则在常量池中新建该字符串对象

**字符串new方式创建:**

查找常量池中是否存在该字符串对象

a. 如果存在则不会在常量池中创建该字符串对象

b. 如果不存在则在常量池中创建该字符串对象，并且在堆中创建该字符串对象，返回堆中字符串对象的引用。

简答: 如果字符串常量池中不存在该字符串对象，首先会在常量池中创建该字符串对象，然后会在堆中创建该字符串对象

| **异同点**  | **常量方式创建** | **new方式创建** |
| -------- | ---------- | ----------- |
| **内存位置** | 字符串常量池     | 堆           |
| **行为**   | 有则复用，无则新建  | 每次新建        |
| **常量池**  | 总是使用       | 可能触发常量池创建   |
| **对象复用** | 复用         | 不复用，每次新建    |
| **内存占用** | 节省内存       | 内存开销大       |

## `String`、`StringBuilder`和`StringBuffer`有什么区别？

| **异同点**  | **String** | **StringBuffer**      | **StringBuilder** |
| -------- | ---------- | --------------------- | ----------------- |
| **线程安全** | 安全，常量      | 安全，synchronized       | 非安全               |
| **性能**   | 较低         | 中等                    | 高效                |
| **父类**   | Object     | AbstractStringBuilder |                   |
| **可变性**  | 不可变        | 可变                    |                   |
| **适用场景** | 修改、拼接较少    | 多线程修改、拼接              | 单线程修改、拼接          |

## 为什么`StringBuilder`的拼接效率高?
1. String没有拼接能力, String的+拼接底层采用SB.append方法完成拼接, 还需要toSTring转为SB字符串才行, 频繁地向堆中申请空间, 造成资源浪费, 耗时比较久
2. StringBuilder自始至终 持有一个StringBuilder对象, 运行效率高, 运行速度快

## 为什么`String`类是不可变的?
1. 保存字符串的数组被`private final`修饰, 并且未提供/暴露修改这个数组的方法
2. String类被final修饰, 使其不能有子类, 避免子类修改String

注意: jdk9之前, 底层是`char[]`, jdk9+, 底层是`byte[]`

## `String`类的常用方法有哪些?
```java
String() 构造方法
length() 获取长度
charAt() 获取指定位置的字符
indexOf() 获取字符(串)首次出现的位置
lastIndexOf() 获取字符(串)末次出现的位置
substring() 获取子串, 左闭右开区间
split() 拆分字符串
trim() 去除字符串两端的空白字符
contains() 判断是否包含指定字符序列
replace() 替换字符(串)
getBytes() 获取字节数组
equals() 判断字符串是否相等
equalsIgnoreCase() 判断字符串相等(忽略大小写)
startsWith() 判断字符串开头
endsWith() 判断字符串结尾
toLowerCase() 转成小写
toUpperCase() 转成大写
ValueOf() 数字转字符串
isBlank() 判空
isEmpty() 判空
```

## 重载(`overload`)和重写(`override`)有什么区别?

| **异同点**     | **重载** | **重写**              |
| ----------- | ------ | ------------------- |
| **发生范围**    | 同一个类   | 子类                  |
| **方法名**     | 相同     | 相同                  |
| **参数列表**    | 不相同    | 相同                  |
| **访问权限**    | 无限制    | >=父类                |
| **返回值类型**   | 无限制    | 基本类型=父类<br>引用类型<=父类 |
| **异常类型**    | 无限制    | <=父类                |
| **发生阶段**    | 编译期    | 运行期                 |
| **静态方法**    | 可以重载   | 不能重写(可以被继承)         |
| **final方法** | 可以重载   | 不能重写(可以被继承)         |
| **构造方法**    | 可以重载   | 不能重写(不能被继承)         |

## 泛型有什么优势?泛型有什么局限?

## 异常有哪些分类?

## 怎么处理异常?

## final关键字的作用是什么?
[[jvm]]

